<!DOCTYPE html>
<link href="https://fonts.cdnfonts.com/css/arcade-classic" rel="stylesheet">
<title>Tower Defense</title>
<body>
<body style="background-color:white;">
  <canvas id="myCanvas" width='1200' height='900' style="background-color:#d4f6ff"></canvas>
</body>
<style>

canvas {
    padding: 0;
    margin: auto;
    display: block;
    width: 1200px;
    height: 900px;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    font-family: 'ArcadeClassic', sans-serif;
}
@import url('https://fonts.cdnfonts.com/css/arcade-classic');
                        
</style>
                
<script>
(function() {
  var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  window.requestAnimationFrame = requestAnimationFrame;
})();
// INITIALIZING ALL NECESSARY VARIABLES
var canvas = document.getElementById("myCanvas");
var c = canvas.getContext("2d");
c.font = "30px ArcadeClassic";
c.imageSmoothingEnabled = false;
const NUMCOLS = 15;
const NUMROWS = 10;
const GAMEWIDTH = 900;
const GAMEHEIGHT = 600;
const XOFFSET = (canvas.width-GAMEWIDTH)/2;
const YOFFSET = (canvas.height-GAMEHEIGHT)/2;

var empty = new Image();
empty.src = "images/empty.png";
var tower = new Image();
tower.src = "images/tower.png";

var enemies = [
  {x: XOFFSET, y: YOFFSET, w: 60, h: 60, speed: 1,color: "green", current: 0, pixel: 0},
  {x: XOFFSET, y: YOFFSET, w: 60, h: 60, speed: 3,color: "blue", current: 0, pixel: 0},
  {x: XOFFSET, y: YOFFSET, w: 60, h: 60, speed: 2,color: "red", current: 0, pixel: 0}
];
console.log("THIS GUY STIIINKS");
const level1 = [
1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 
1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 
1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 
1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 
1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];
const level1SS = [0,0];


var towers = []



var bullets = []
var heroButtons = [{
  x: 50, 
  y: 150, 
  w: 60,
  h: 60,
  imgs: [empty, tower]
}]

var selectedLevelMap = level1;
var startingSquare = level1SS;




/*
0  1  2  3  4  5  6  7  8  9
*/
// USE https://gube.live/pingu/grid-template/
var instances = 0;
function calcInstances() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (selectedLevelMap[i] == 1) {
      instances++;
    }
  }
}
calcInstances();


var pathCoords = [];
var pathFound = false;
var startCoord = null;
var previous = [];
var tracker = 0;
var lockedPath = "NONE";
var tmp = null;


function pathFind(selectedLevelMap, startSq) {
  while (!pathFound) {
    if (startCoord == null) {
      previous = [startSq[0], startSq[1]];
      startCoord = previous;
      pathCoords.push(previous);
      continue;
    }
    tracker = previous[0] + previous[1] * NUMCOLS;
    // LOOK UP

    if (pathCoords.length == instances) {
      pathFound = true;
      break;
    }
    if (tracker > NUMCOLS-1) {
      if (lockedPath != "UP") {
        if (selectedLevelMap[tracker - NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] - 1];
          pathCoords.push(previous);
          lockedPath = "DOWN";
          continue;
        }
      }
    }

    if (tracker < NUMCOLS*(NUMROWS-1)) {  // LOOK DOWN
      if (lockedPath != "DOWN") {
        if (selectedLevelMap[tracker + NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] + 1];
          pathCoords.push(previous);
          lockedPath = "UP";
          continue;
        }
      }

    }  // LOOK LEFT
    if (tracker % NUMCOLS != 0) {
      if (lockedPath != "LEFT") {
        if (selectedLevelMap[tracker - 1] == 1) {
          previous = [tracker % NUMCOLS - 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "RIGHT";
          continue;
        }
      }

    }

    if (tracker % NUMCOLS != NUMCOLS-1) {  // LOOK RIGHT
      if (lockedPath != "RIGHT") {
        if (selectedLevelMap[tracker + 1] == 1) {
          previous = [tracker % NUMCOLS + 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "LEFT";
          continue;
        }
      }

    }


  }
}
function drawTowers() {
    c.fillStyle = "red";

    for (let i = 0; i < towers.length; i++) {
      c.drawImage(towers[i].blankimg, towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      //c.drawImage(towers[i].img, towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      var angle = ((Math.atan2(towers[i].dy, towers[i].dx) * 180) / Math.PI);
      //console.log(towers[i]);
      drawRotated(Math.round(angle+90), towers[i]); // angle + 90 since we start at pi/2
    }

  window.requestAnimationFrame(drawTowers);
}

function drawRotated(degrees, tower){ // draw  a tower with rotation
    //c.clearRect(0,0,canvas.width,canvas.height);

    // save the unrotated context of the canvas so we can restore it later
    // the alternative is to untranslate & unrotate after drawing
    c.save();

    // move to the center of the canvas
    c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

    // rotate the canvas to the specified degrees
    c.rotate(degrees*Math.PI/180);

    // draw the image
    // since the context is rotated, the image will be rotated also
    c.drawImage(tower.img, -tower.w/2,-tower.h/2, tower.w, tower.h);

    // weâ€™re done with the rotating so restore the unrotated context
    c.restore();
}

var coords = [];
var directions = [];
var currentRow = 0;


function createDirections() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
        console.log(i);
        currentRow++;
      }
      coords.push({
        x: XOFFSET + (i % NUMCOLS)*60,
        y: YOFFSET + (currentRow)*60,
        w: 60,
        h: 60,
        value: selectedLevelMap[i],
        rx: i % NUMCOLS,
        ry: currentRow
      });
      //c.fillRect((i % rows)*60, (currentRow)*60, 60, 60);
    }

  for (let i = 0; i < pathCoords.length; i++) {
    for (let x = 0; x < coords.length; x++) {
      if (pathCoords[i][0] == coords[x].rx && pathCoords[i][1] == coords[x].ry) {
        directions.push(coords[x]);
        continue;
      }
    }
  }
  console.log(directions);

}


pathFind(level1, level1SS);
createDirections();



function drawBullets() {
  c.fillStyle = "green";
  for (let i = 0; i < bullets.length; i++) {
    c.fillRect(bullets[i].x, bullets[i].y, bullets[i].w, bullets[i].h);
    bullets[i].x += bullets[i].dx;
    bullets[i].y += bullets[i].dy;
  }

  window.requestAnimationFrame(drawBullets);
}

function drawBackground() {
  var filtered = bullets.filter(function (el) {
  return el != null;
  });
  bullets = filtered;
  var filtered = enemies.filter(function (el) {
  return el != null;
  });
  enemies = filtered;




  c.clearRect(0,0,canvas.width, canvas.height);
  currentRow = 0;
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
      currentRow++;
    }
    if (selectedLevelMap[i] == 0) {
      c.fillStyle = "black";
    }
    else {
      c.fillStyle = "white";
    }
    c.fillRect(XOFFSET + (i % NUMCOLS)*60, YOFFSET + (currentRow)*60, GAMEWIDTH / NUMCOLS, GAMEHEIGHT / NUMROWS);
  }
  window.requestAnimationFrame(drawBackground);
}

function drawEnemies() {
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    c.fillStyle = enemies[i].color;
    c.fillRect(enemies[i].x, enemies[i].y, enemies[i].w, enemies[i].h);
  }
  window.requestAnimationFrame(drawEnemies);
}

function moveEnemies() {
  if (directions.length == 0) {
        return;
      }
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current == directions.length) {
      enemies[i] = null;
      continue;
    }
        if (directions[enemies[i].current].x < directions[enemies[i].current+1].x) {
          enemies[i].x+=enemies[i].speed;

        }
        else if (directions[enemies[i].current].x > directions[enemies[i].current+1].x) {
          enemies[i].x-=enemies[i].speed;

        }
        else if (directions[enemies[i].current].y < directions[enemies[i].current+1].y) {
          enemies[i].y+=enemies[i].speed;

        }
        else if (directions[enemies[i].current].y > directions[enemies[i].current+1].y) {
          enemies[i].y-=enemies[i].speed;

        }


    enemies[i].pixel+=enemies[i].speed;


    if (enemies[i].pixel >= 60) {
      enemies[i].current++;
      if (enemies[i].current == directions.length-1) {
        enemies[i] = null;
        continue;
      }
        if (directions.length > 0 && enemies[i].current < directions.length) {
          enemies[i].x = directions[enemies[i].current].x;
          enemies[i].y = directions[enemies[i].current].y;
        }

        enemies[i].pixel = 0;
      }

  }
  window.requestAnimationFrame(moveEnemies);
}

function drawHeroButtons() {
  for (let i = 0; i < heroButtons.length; i++) {
    for (let x = 0; x < heroButtons[i].imgs.length; x++) {
      c.drawImage(heroButtons[i].imgs[x], heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
    }
  }
  if (tmp != null) {
    for (let x = 0; x < tmp.imgs.length; x++) {
      c.drawImage(tmp.imgs[x], tmp.x, tmp.y, tmp.w, tmp.h);
    }
  }
  window.requestAnimationFrame(drawHeroButtons);
}

drawBackground();
drawHeroButtons();
drawBullets()
drawTowers();
drawEnemies();
moveEnemies();


function shoot() {
  if (enemies.length == 0) {
    return;
  }
  for (let i = 0; i < towers.length; i++) {
    addBullet({x: 0, y: 0, w: 60/2, h: 60/2}, towers[i]);
  }
}

//HELPER FUNCTIONS
var seconds = 0;
function Timer() { // game timer
  seconds+=.15;
    for (let x = 0; x < bullets.length; x++) {
      if (bullets[x] == null) {
        continue;
      }
        if (enemies[bullets[x].twr.target] != null) {
          updateBullet(bullets[x], enemies[bullets[x].twr.target]);
        }

      }    
}


function adjustTowers() { // updates target and tower dy dx
  var closestEnemy = -1;
  var maxNum = -1;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current > maxNum) {
      closestEnemy = enemies[i];
      maxNum = enemies[i].current;
    }
  }
  for (let x = 0; x < towers.length; x++) {
    if (closestEnemy != -1) {
      towers[x].target = enemies.indexOf(closestEnemy);
      towers[x].dx = closestEnemy.x-towers[x].x;
      towers[x].dy = closestEnemy.y-towers[x].y;
    }
  }


}


setInterval(shoot, 50);
setInterval(Timer, 15);
setInterval(adjustTowers, 10);

function getRandomIntInclusive(min, max) { // random function for ghost movement, returns integers
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive
}

function isInside(pos, arr) {
  for (let i =0; i < arr.length; i++) {
    if (arr[i] != null) {
      if (pos.x > arr[i].x && pos.x < arr[i].x + arr[i].w && pos.y < arr[i].y + arr[i].h && pos.y > arr[i].y) {
        return arr[i];
      }
    }
  }
  return null;
}

function getMousePos(canvas, event) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  };
}

function randomN(lower, upper) { // random num gen from min to max (inclusive), returns floats
  return Math.random() * (upper - lower) + lower;
}

function snap() {
  var snapX = tmp.x+tmp.w/2;
  var snapY = tmp.y+tmp.h/2;
  var found = false;

  for (let i = 0; i < coords.length; i++) {
    if (coords[i].value == 0) {
      var coordX = coords[i].x+coords[i].w/2;
      var coordY = coords[i].y+coords[i].h/2;

      if ((coordX + 30 > snapX && coordX < snapX) || (coordX - 30 < snapX && coordX > snapX)) {
        if ((coordY + 30 > snapY && coordY < snapY) || (coordY - 30 < snapY && coordY > snapY)) {
          tmp.x = coords[i].x;
          tmp.y = coords[i].y;
          found = true;
        }
      }
    }
  }
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].x == tmp.x && towers[i].y == tmp.y) {
      tmp = null;
    }
  }

  if (!found) {
    tmp = null;
  }
}



//EVENT LISTENERS
canvas.addEventListener("mousemove", function (event) {
  var mousePos = getMousePos(canvas, event);
  //updateBullet(bullets[bullets.length-1], mousePos);
  if (tmp != null) {
    tmp.x = mousePos.x-tmp.w/2;
    tmp.y = mousePos.y-tmp.h/2;
  }
}, false);

canvas.addEventListener("mouseup", function (event) {
  var mousePos = getMousePos(canvas, event);
  if (tmp != null) {
    snap();
    if (tmp != null) {
      towers.push({
        x: tmp.x,
        y: tmp.y,
        w: tmp.w,
        h: tmp.h,
        target: -1,
        blankimg: empty,
        img: tower

      });
    }

  }
  tmp = null;
  //updateBullet(bullets[bullets.length-1], mousePos);
}, false);

canvas.addEventListener("mousedown", function (event) {
  var mousePos = getMousePos(canvas, event);
  var selectedHero = isInside(mousePos, heroButtons);
  if (selectedHero == null) {
    tmp = null;
    return;
  }
  tmp = {
    x: selectedHero.x,
    y: selectedHero.y,
    w: selectedHero.w, 
    h: selectedHero.h,
    imgs: selectedHero.imgs
  }
  tmp.x = mousePos.x-tmp.w/2;
  tmp.y = mousePos.y-tmp.h/2;


}, false);







function addBullet(position, tower) {

  bullets.push({
  x: tower.x + tower.w/2-5, 
  y: tower.y + tower.h/2, 
  dx: 0, 
  dy: 0, 
  w: 10, 
  h: 10,
  twr: tower
});
  updateBullet(bullets[bullets.length-1], position);
}

function updateBullet(bullet, position) {
  const AVERAGESPEED = 3; // AVG == 2 --> 1.95 is what it comes out to, keep in mind
  var changeX = (position.x+position.w/2-bullet.x);
  var changeY = (position.y+position.w/2-bullet.y);

  changeX /=100;
  changeY /=100;


  while (changeX < AVERAGESPEED && changeY < AVERAGESPEED && changeX > 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY > -AVERAGESPEED && changeX < 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY < AVERAGESPEED && changeX < 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX < AVERAGESPEED && changeY > -AVERAGESPEED && changeX > 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > AVERAGESPEED || changeY > AVERAGESPEED || changeX < -AVERAGESPEED || changeY < -AVERAGESPEED) {
    changeX /= 1.05;
    changeY /= 1.05;
  }

  bullet.dx = changeX;
  bullet.dy = changeY;
}



canvas.addEventListener('click', function(event) {
  var mousePos = getMousePos(canvas, event);
  //addBullet(mousePos, towers[towers.length-1]);
}, false);
</script>


</html>

