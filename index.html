<!DOCTYPE html>
<link href="https://fonts.cdnfonts.com/css/arcade-classic" rel="stylesheet">
<title>Tower Defense</title>
<body>
<body style="background-color:#000000;">
  <canvas id="myCanvas" width='1300' height='900' style="background-color:#000000"></canvas>
</body>
<style>

canvas {
    padding: 0;
    margin: auto;
    display: block;
    width: 1300px;
    height: 900px;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    font-family: 'ArcadeClassic', sans-serif;
}
@import url('https://fonts.cdnfonts.com/css/arcade-classic');
                        
</style>
                
<script>
(function() {
  var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  window.requestAnimationFrame = requestAnimationFrame;
})();
// INITIALIZING ALL NECESSARY VARIABLES
var canvas = document.getElementById("myCanvas");
var c = canvas.getContext("2d");
c.font = "30px ArcadeClassic";
c.imageSmoothingEnabled = false;
const NUMCOLS = 15;
const NUMROWS = 10;
const BOXWH = 60;
const GAMEWIDTH = BOXWH*NUMCOLS;
const GAMEHEIGHT = BOXWH*NUMROWS;

const XOFFSET = (canvas.width-GAMEWIDTH)/2;
const YOFFSET = (canvas.height-GAMEHEIGHT)/2;

// GAMEPLAY MECHANICS
const GAMESPEED = .25;
const CANNONRANGE = 20;
const GUNNERSPEED = 5*GAMESPEED;
const CANNONSPEED = 2*GAMESPEED;
const CANNONFIRERATE = 500*(1/GAMESPEED);
const GUNNERFIRERATE = 100*(1/GAMESPEED);
const ENEMYSIZE = 70;


var waveCount = 0;

var emptyblank = new Image();
emptyblank.src = "images/greyblank.png";

var emptyGunner = new Image();
emptyGunner.src = "images/gunner/empty.png";
var gunnerImage = new Image();
gunnerImage.src = "images/gunner/tower.png";
var gunnerball = new Image();
gunnerball.src = "images/gunner/gunnerball.png";


var emptyCannon = new Image();
emptyCannon.src = "images/cannon/empty.png";
var cannonImage = new Image();
cannonImage.src = "images/cannon/cannon.png";
var cannonball = new Image();
cannonball.src = "images/cannon/cannonball.png";

var backG = new Image();
backG.src = "images/backgtd2.png";

var enemies = [
];
const level1 = [
1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 
1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 
1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 
1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 
1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];
const level1SS = [0,0];

var seconds = 0;
var towers = []
var GUNNER = "gunner";
var CANNON = "cannon";

var bullets = []
const TOWEROFFSETX = 72;
const TOWEROFFSETY = 110;

var heroButtons = [{
  type: GUNNER,
  x: 41, 
  y: 209, 
  w: BOXWH,
  h: BOXWH,
  imgs: [emptyblank, gunnerImage],
  real: emptyGunner,
  bullet: gunnerball,
  price: 200
},
  {
  type: CANNON,
  x: 41+TOWEROFFSETX, 
  y: 209, 
  w: BOXWH,
  h: BOXWH,
  imgs: [emptyblank, cannonImage],
  real: emptyCannon,
  bullet: cannonball,
  price: 300

}]

var selectedLevelMap = level1;
var startingSquare = level1SS;




/*
0  1  2  3  4  5  6  7  8  9
*/
// USE https://gube.live/pingu/grid-template/
var instances = 0;
function calcInstances() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (selectedLevelMap[i] == 1) {
      instances++;
    }
  }
}
calcInstances();

var nextWaveBlank = new Image();
nextWaveBlank.src = "images/nextWave/pixil-frame-0.png";
var wave0 = new Image();
wave0.src = "images/nextWave/pixil-frame-1.png";
var wave1 = new Image();
wave1.src = "images/nextWave/pixil-frame-2.png";
var wave2 = new Image();
wave2.src = "images/nextWave/pixil-frame-3.png";

var start0 = new Image();
start0.src = "images/startButton/pixil-frame-0.png";
var start1 = new Image();
start1.src = "images/startButton/pixil-frame-1.png";

var flesh = new Image();
flesh.src = "images/flesh23.png";

var nextWaveButton = {
  x: canvas.width/2-150/2,
  y: 50,
  w: 150,
  h: 50,
  imgs: [start0, start1],
  hover: false,
  index: 0
};
var buttons = [nextWaveButton];


var redEI = new Image();
redEI.src = "images/enemies/pixil-frame-0.png";
var blueEI = new Image();
blueEI.src = "images/enemies/pixil-frame-1.png";
var greenEI = new Image();
greenEI.src = "images/enemies/pixil-frame-2.png";
var grayEI = new Image();
grayEI.src = "images/enemies/pixil-frame-3.png";
var brownEI = new Image();
brownEI.src = "images/enemies/pixil-frame-4.png";
var pinkEI = new Image();
pinkEI.src = "images/enemies/pixil-frame-5.png";
var limeEI = new Image();
limeEI.src = "images/enemies/pixil-frame-6.png";
var aquaEI = new Image();
aquaEI.src = "images/enemies/pixil-frame-7.png";
var orangeEI = new Image();
orangeEI.src = "images/enemies/pixil-frame-8.png";
var purpleEI = new Image();
purpleEI.src = "images/enemies/pixil-frame-9.png";

var rocketTypes = [
  {
    desc: "red, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: redEI,
    current: 0, 
    pixel: 0, 
    health: 1, 
  },
  {
    desc: "blue, FAST",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 4*GAMESPEED, 
    color: blueEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "green, SLOW CHUNKY BOY",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: greenEI,
    current: 0, 
    pixel: 0,
    health: 5, 
  },
  {
    desc: "gray, FAST AND CHUNKY",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 3*GAMESPEED, 
    color: grayEI,
    current: 0, 
    pixel: 0,
    health: 4, 
  },  
  {
    desc: "brown, slow and bad",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: brownEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "pink, dies spawns more",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: pinkEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "lime, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: limeEI,
    current: 0, 
    pixel: 0, 
    health: 2, 
  },
  {
    desc: "aqua, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: aquaEI,
    current: 0, 
    pixel: 0, 
    health: 2, 
  },
  {
    desc: "orange, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: orangeEI,
    current: 0, 
    pixel: 0, 
    health: 2, 
  },
  {
    desc: "purple, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: purpleEI,
    current: 0, 
    pixel: 0, 
    health: 2, 
  }
]

var waves = [
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       0,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 0
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 1
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 2
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      0,      0,      0,      0,       0,       0],
    waveNum: 3
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      10,      0,      0,      0,       0,       0],
    waveNum: 4
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      10,      1,      0,      0,       0,       0],
    waveNum: 5
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       0,      0,       0,      0,      10,      0,      0,       0,       0],
    waveNum: 6
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      10,      0,      0,       0,       0],
    waveNum: 7
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      10,      10,      10,       0,       0],
    waveNum: 8
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      10,      10,      10,      10,       10,       10],
    waveNum: 9
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      15,      15,      15,       15,       15],
    waveNum: 10
  }
]

var colorArr = [redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI];
var pathCoords = [];
var pathFound = false;
var startCoord = null;
var previous = [];
var tracker = 0;
var lockedPath = "NONE";
var tmp = null;
var coords = [];
var directions = [];
var currentRow = 0;
var balance = 600;

function pathFind(selectedLevelMap, startSq) {
  while (!pathFound) {
    if (startCoord == null) {
      previous = [startSq[0], startSq[1]];
      startCoord = previous;
      pathCoords.push(previous);
      continue;
    }
    tracker = previous[0] + previous[1] * NUMCOLS;
    // LOOK UP

    if (pathCoords.length == instances) {
      pathFound = true;
      break;
    }
    if (tracker > NUMCOLS-1) {
      if (lockedPath != "UP") {
        if (selectedLevelMap[tracker - NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] - 1];
          pathCoords.push(previous);
          lockedPath = "DOWN";
          continue;
        }
      }
    }

    if (tracker < NUMCOLS*(NUMROWS-1)) {  // LOOK DOWN
      if (lockedPath != "DOWN") {
        if (selectedLevelMap[tracker + NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] + 1];
          pathCoords.push(previous);
          lockedPath = "UP";
          continue;
        }
      }

    }  // LOOK LEFT
    if (tracker % NUMCOLS != 0) {
      if (lockedPath != "LEFT") {
        if (selectedLevelMap[tracker - 1] == 1) {
          previous = [tracker % NUMCOLS - 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "RIGHT";
          continue;
        }
      }

    }

    if (tracker % NUMCOLS != NUMCOLS-1) {  // LOOK RIGHT
      if (lockedPath != "RIGHT") {
        if (selectedLevelMap[tracker + 1] == 1) {
          previous = [tracker % NUMCOLS + 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "LEFT";
          continue;
        }
      }

    }


  }
}

function drawTowers() {
    c.fillStyle = "red";

    for (let i = 0; i < towers.length; i++) {
      c.drawImage(towers[i].blankimg, towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      //c.drawImage(towers[i].img, towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      var angle = ((Math.atan2(towers[i].dy, towers[i].dx) * 180) / Math.PI);
      drawRotated(Math.round(angle+90), towers[i]); // angle + 90 since we start at pi/2
    }

  window.requestAnimationFrame(drawTowers);
}

function drawRotated(degrees, tower){ // draw  a tower with rotation
    //c.clearRect(0,0,canvas.width,canvas.height);

    // save the unrotated context of the canvas so we can restore it later
    // the alternative is to untranslate & unrotate after drawing
    c.save();

    // move to the center of the canvas
    c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

    // rotate the canvas to the specified degrees
    c.rotate(degrees*Math.PI/180);

    // draw the image
    // since the context is rotated, the image will be rotated also
    c.drawImage(tower.img, -tower.w/2,-tower.h/2, tower.w, tower.h);

    // were done with the rotating so restore the unrotated context
    c.restore();
}

function drawRotatedEnemies(degrees, tower) {
  c.save();

  // move to the center of the canvas
  c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

  // rotate the canvas to the specified degrees
  c.rotate(degrees*Math.PI/180);

  // draw the image
  // since the context is rotated, the image will be rotated also
  c.drawImage(tower.color, -ENEMYSIZE/2,-ENEMYSIZE/2, ENEMYSIZE, ENEMYSIZE);

  // we’re done with the rotating so restore the unrotated context
  c.restore();
}

function drawRotatedCannon(degrees, tower) {
  //c.drawImage(bullets[i].twr.bullet, bullets[i].x, bullets[i].y, bullets[i].w*2, bullets[i].h*2);
  c.save();

// move to the center of the canvas
  c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

  // rotate the canvas to the specified degrees
  c.rotate(degrees*Math.PI/180);

  // draw the image
  // since the context is rotated, the image will be rotated also
  c.drawImage(tower.twr.bullet, -tower.w/2,-tower.h/2, tower.w*2, tower.h*2);

  // we’re done with the rotating so restore the unrotated context
  c.restore();
}

function createDirections() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
        currentRow++;
      }
      coords.push({
        x: XOFFSET + (i % NUMCOLS)*BOXWH,
        y: YOFFSET + (currentRow)*BOXWH,
        w: BOXWH,
        h: BOXWH,
        value: selectedLevelMap[i],
        rx: i % NUMCOLS,
        ry: currentRow
      });
      //c.fillRect((i % rows)*60, (currentRow)*60, 60, 60);
    }

  for (let i = 0; i < pathCoords.length; i++) {
    for (let x = 0; x < coords.length; x++) {
      if (pathCoords[i][0] == coords[x].rx && pathCoords[i][1] == coords[x].ry) {
        directions.push(coords[x]);
        continue;
      }
    }
  }

}

function drawBullets() {
  clean();

  for (let i = 0; i < bullets.length; i++) {
    if (bullets[i].twr.type == GUNNER) {
      c.fillStyle = "green";
      c.beginPath();
      c.arc(bullets[i].x + bullets[i].w/2, bullets[i].y + bullets[i].h/2, 5, 0, Math.PI * 2);
      c.closePath();
      c.fill();
      //c.drawImage(bullets[i].twr.bullet, bullets[i].x, bullets[i].y, bullets[i].w*2, bullets[i].h*2);
    }
    else if (bullets[i].twr.type == CANNON) {
      //drawRotatedCannon(seconds*60 % 365, bullets[i]);
      c.drawImage(bullets[i].twr.bullet, bullets[i].x,bullets[i].y, bullets[i].w*2, bullets[i].h*2);
    }
      bullets[i].x += bullets[i].dx;
      bullets[i].y += bullets[i].dy;
      if (bullets[i].x < 0-bullets[i].w || bullets[i].x > canvas.width || bullets[i].y < 0-bullets[i].h || bullets[i].y > canvas.height) {
        bullets[i] = null;
      }
  }


  window.requestAnimationFrame(drawBullets);
}

function drawBackground() {


  c.clearRect(0,0,canvas.width, canvas.height);
  currentRow = 0;
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
      currentRow++;
    }
    if (selectedLevelMap[i] == 0) {
      c.fillStyle = "black";
    }
    else {
      c.fillStyle = "white";
    }
    c.fillRect(XOFFSET + (i % NUMCOLS)*BOXWH, YOFFSET + (currentRow)*BOXWH, GAMEWIDTH / NUMCOLS, GAMEHEIGHT / NUMROWS);
  }
  c.drawImage(flesh, 0, 0, canvas.width, canvas.height);
  c.drawImage(backG, XOFFSET, YOFFSET, GAMEWIDTH, GAMEHEIGHT);
  window.requestAnimationFrame(drawBackground);
}

function drawEnemies() {
  clean();
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].x+enemies[i].w/2-10 >= XOFFSET) {
      enemies[i].active = true;
      drawRotatedEnemies((enemies[i].dir-1)*90, enemies[i]);
      //c.drawImage(enemies[i].color, enemies[i].x, enemies[i].y, enemies[i].w, enemies[i].h);
    }

  }
  window.requestAnimationFrame(drawEnemies);
}

function moveEnemies() {
  clean();
  if (directions.length == 0) {
        return;
      }
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].x < XOFFSET) {
      enemies[i].x+=enemies[i].speed;
      continue;
    }
    if (enemies[i].health <= 0) {
      balance+=2;
      if (enemies[i].color == pinkEI) {
        generateEnemies(10, enemies[i]);
        //clean();
      }
      enemies[i] = null;
    }
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current == directions.length) {
      enemies[i] = null;
      continue;
    }
    if (enemies[i].current < directions.length-1) {
      if (directions[enemies[i].current].x < directions[enemies[i].current+1].x) {
          enemies[i].x+=enemies[i].speed;
          enemies[i].dir = 1;

        }
        else if (directions[enemies[i].current].x > directions[enemies[i].current+1].x) {
          enemies[i].x-=enemies[i].speed;
          enemies[i].dir = 3;
        }
        else if (directions[enemies[i].current].y < directions[enemies[i].current+1].y) {
          enemies[i].y+=enemies[i].speed;
          enemies[i].dir = 2;

        }
        else if (directions[enemies[i].current].y > directions[enemies[i].current+1].y) {
          enemies[i].y-=enemies[i].speed;
          enemies[i].dir = 0;
        }
    }


    enemies[i].pixel+=enemies[i].speed;



    if (enemies[i].pixel >= BOXWH) {
      enemies[i].current++;
      if (enemies[i].current == directions.length-1) {
        enemies[i] = null;
        continue;
      }
        if (directions.length > 0 && enemies[i].current < directions.length) {
          enemies[i].x = directions[enemies[i].current].x;
          enemies[i].y = directions[enemies[i].current].y;
        }

        enemies[i].pixel = 0;
      }

  }
  window.requestAnimationFrame(moveEnemies);
}

function drawStroked(text, x, y) {
    c.strokeStyle = 'black';
    c.lineWidth = 3;
    c.strokeText(text, x, y);
    c.fillStyle = 'white';
    c.fillText(text, x, y);
}

function drawHeroButtons() {
  const textOffsetX = 30;
  const textOffsetY = 75;
  c.textAlign = "center";
  c.font = "15px ArcadeClassic";
  for (let i = 0; i < heroButtons.length; i++) {
    for (let x = 0; x < heroButtons[i].imgs.length; x++) {
      if (x == 0) {
        if (balance >= heroButtons[i].price) {
          c.drawImage(heroButtons[i].real, heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
        }
        else {
          c.drawImage(heroButtons[i].imgs[x], heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
        }
      }
      else {
        c.drawImage(heroButtons[i].imgs[x], heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
      }
      c.fillStyle = "white";
      drawStroked("$  " + heroButtons[i].price, heroButtons[i].x+textOffsetX, heroButtons[i].y+textOffsetY)
    }
  }
  if (tmp != null) {
    for (let x = 0; x < tmp.imgs.length; x++) {
      c.drawImage(tmp.imgs[x], tmp.x, tmp.y, tmp.w, tmp.h);
    }
  }
  c.font = "25px ArcadeClassic";
  drawStroked("Balance:   $ " + balance, GAMEWIDTH+XOFFSET, YOFFSET-50);
  drawStroked("Wave   " + waveCount, GAMEWIDTH+XOFFSET, YOFFSET-20)
  window.requestAnimationFrame(drawHeroButtons);
}

function generateEnemies(numOfEnemies, enemy = {x: -1, y: 0}) { // generation for pink
  for (let i = 0; i < numOfEnemies; i++) {
    var rand = getRandomIntInclusive(0, rocketTypes.length-1);
    var SoffSet = 1*((numOfEnemies-i)/numOfEnemies);
    enemies.push({
      desc: rocketTypes[rand].desc,
      dir: rocketTypes[rand].dir, 
      x: XOFFSET, 
      y: YOFFSET, 
      w: BOXWH, 
      h: BOXWH, 
      speed: rocketTypes[rand].speed+SoffSet, 
      color: rocketTypes[rand].color,
      current: rocketTypes[rand].current, 
      pixel: rocketTypes[rand].pixel,
      health: rocketTypes[rand].health, 
      active: false
    });
    if (enemy.x != -1) {
      while (enemies[enemies.length-1].color == pinkEI) {
        var rand = getRandomIntInclusive(0, rocketTypes.length-1);
        enemies[enemies.length-1] = ({
          desc: rocketTypes[rand].desc,
          dir: enemy.dir, 
          x: enemy.x, 
          y: enemy.y, 
          w: BOXWH, 
          h: BOXWH, 
          speed: rocketTypes[rand].speed+SoffSet, 
          color: rocketTypes[rand].color,
          current: enemy.current, 
          pixel: rocketTypes[rand].pixel,
          health: rocketTypes[rand].health,
          active: false
        });
      }
      enemies[enemies.length-1].x = enemy.x;
      enemies[enemies.length-1].y = enemy.y;
      enemies[enemies.length-1].dir =  enemy.dir;
      enemies[enemies.length-1].current = enemy.current;

    }


  } // dir: 0 --> UP,   1 --> RIGHT,   2 --> DOWN,   3 --> LEFT
}

function countRockets(wave) {
  var total = 0;
  for (let i = 0; i < wave.arr.length; i++) {
    total+=wave.arr[i];
  }
  return total;
}

function generateWave(wave) { // main generation func
  var rocketCount = countRockets(wave);
  var SoffSet = 0;
  for (let i = 0; i < wave.arr.length; i++) {
    for (let x = 0; x < wave.arr[i]; x++) {
      SoffSet+=1;
      enemies.push({
        desc: rocketTypes[i].desc,
        dir: rocketTypes[i].dir, 
        x: XOFFSET-90-SoffSet*4,
        y: YOFFSET, 
        w: BOXWH, 
        h: BOXWH, 
        speed: rocketTypes[i].speed, 
        color: rocketTypes[i].color,
        current: rocketTypes[i].current, 
        pixel: rocketTypes[i].pixel,
        health: rocketTypes[i].health,
        active: false 
      });
    }
  }
}

function shootGunner() {
  if (enemies.length == 0) {
    return;
  }
  var active = false;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].active) {
      active = true;
    }
  }
  if (active) {
    for (let i = 0; i < towers.length; i++) {
      if (towers[i].type == GUNNER) {
        addBullet({x: 0, y: 0, w: BOXWH/2, h: BOXWH/2}, towers[i]);
      }
    }
  }

}

function adjustTowers() { // updates target and tower dy dx
  var closestEnemy = -1;
  var maxNum = -1;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current > maxNum) {
      closestEnemy = enemies[i];
      maxNum = enemies[i].current;
    }
  }
  for (let x = 0; x < towers.length; x++) {
    if (closestEnemy != -1) {
      towers[x].target = enemies.indexOf(closestEnemy);
      towers[x].dx = closestEnemy.x-towers[x].x;
      towers[x].dy = closestEnemy.y-towers[x].y;
    }
  }


}

function shootCannon() {
  if (enemies.length == 0) {
    return;
  }
  var active = false;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].active) {
      active = true;
    }
  }
  if (active) {
    for (let i = 0; i < towers.length; i++) {
      if (towers[i].type == CANNON) {
        addBullet({x: 0, y: 0, w: BOXWH/2, h: BOXWH/2}, towers[i]);
      }
    }
  }
}

function drawButtons() {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i] == nextWaveButton) {
      if (enemies.length == 0) {
        if (buttons[i].hover) {
          c.drawImage(buttons[i].imgs[1], buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h*3);
        }
        else {
          c.drawImage(buttons[i].imgs[0], buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h*3);
        }
      }
    }

  }

  window.requestAnimationFrame(drawButtons);
}

function animsUI() {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i] == nextWaveButton) {
      buttons[i].index += 1;
      buttons[i].index %= buttons[i].imgs.length;
    }
  }
}

pathFind(level1, level1SS);
createDirections();
drawBackground();
drawButtons();
drawHeroButtons();
drawBullets();
drawTowers();
drawEnemies();
moveEnemies();
generateWave(waves[waveCount]);
waveCount++;
setInterval(shootGunner, GUNNERFIRERATE);
setInterval(shootCannon, CANNONFIRERATE);
setInterval(animsUI, 50);
setInterval(Timer, 15);
setInterval(adjustTowers, 10);

function getRandomIntInclusive(min, max) { // random function for ghost movement, returns integers
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive
}

function isInside(pos, arr) {
  for (let i =0; i < arr.length; i++) {
    if (arr[i] != null) {
      if (pos.x > arr[i].x && pos.x < arr[i].x + arr[i].w && pos.y < arr[i].y + arr[i].h && pos.y > arr[i].y) {
        return arr[i];
      }
    }
  }
  return null;
}

function isInsideCannon(pos, arr) {
  var found = false;
    for (let i =0; i < arr.length; i++) {
      if (arr[i] != null) {
        if (pos.x+CANNONRANGE > arr[i].x && pos.x-CANNONRANGE < arr[i].x + arr[i].w && pos.y-CANNONRANGE < arr[i].y + arr[i].h && pos.y+CANNONRANGE > arr[i].y) {
          arr[i].health -= 5;
          found = true;
        }
      }
    }
  if (!found) {
    return null;
  }
  else {
    return 0;
  }

}

function getMousePos(canvas, event) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  };
}

function randomN(lower, upper) { // random num gen from min to max (inclusive), returns floats
  return Math.random() * (upper - lower) + lower;
}

function snap() {
  var snapX = tmp.x+tmp.w/2;
  var snapY = tmp.y+tmp.h/2;
  var found = false;

  for (let i = 0; i < coords.length; i++) {
    if (coords[i].value == 0) {
      var coordX = coords[i].x+coords[i].w/2;
      var coordY = coords[i].y+coords[i].h/2;

      if ((coordX + 30 > snapX && coordX < snapX) || (coordX - 30 < snapX && coordX > snapX)) {
        if ((coordY + 30 > snapY && coordY < snapY) || (coordY - 30 < snapY && coordY > snapY)) {
          tmp.x = coords[i].x;
          tmp.y = coords[i].y;
          found = true;
        }
      }
    }
  }
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].x == tmp.x && towers[i].y == tmp.y) {
      tmp = null;
    }
  }

  if (!found) {
    tmp = null;
  }
}



//EVENT LISTENERS
canvas.addEventListener("mousemove", function (event) {
  var mousePos = getMousePos(canvas, event);
  //updateBullet(bullets[bullets.length-1], mousePos);
  hoverButton = isInside(mousePos, buttons)

  if (tmp != null) {
    tmp.x = mousePos.x-tmp.w/2;
    tmp.y = mousePos.y-tmp.h/2;
  }
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].hover = false;
  }
  if (hoverButton == null) {
    return;    
  }
  hoverButton.hover = true;


}, false);

canvas.addEventListener("mouseup", function (event) {
  var mousePos = getMousePos(canvas, event);
  if (tmp != null) {
    snap();
    if (tmp != null) {
      balance -= tmp.price;
      if (tmp.type == GUNNER) {
        towers.push({
          type: tmp.type,
          x: tmp.x,
          y: tmp.y,
          w: tmp.w,
          h: tmp.h,
          target: -1,
          blankimg: emptyGunner,
          img: gunnerImage,
          bullet: tmp.bullet
        });
      }
      else if (tmp.type == CANNON) {
        towers.push({
          type: tmp.type,
          x: tmp.x,
          y: tmp.y,
          w: tmp.w,
          h: tmp.h,
          target: -1,
          blankimg: emptyCannon,
          img: cannonImage,
          bullet: tmp.bullet
        })
      }

    }

  }
  tmp = null;
  //updateBullet(bullets[bullets.length-1], mousePos);
}, false);

canvas.addEventListener("mousedown", function (event) {
  var mousePos = getMousePos(canvas, event);
  var selectedHero = isInside(mousePos, heroButtons);
  if (selectedHero == null) {
    tmp = null;
    return;
  }
  if (balance >= selectedHero.price) {
    tmp = {
      type: selectedHero.type,
      x: selectedHero.x,
      y: selectedHero.y,
      w: selectedHero.w, 
      h: selectedHero.h,
      imgs: selectedHero.imgs,
      bullet: selectedHero.bullet,
      price: selectedHero.price
    }
    tmp.x = mousePos.x-tmp.w/2;
    tmp.y = mousePos.y-tmp.h/2;
  }



}, false);







function addBullet(position, tower) {
  if (tower.type == GUNNER) {
    bullets.push({
      x: tower.x + tower.w/2-5, 
      y: tower.y + tower.h/2, 
      dx: 0, 
      dy: 0, 
      w: BOXWH/6, 
      h: BOXWH/6,
      twr: tower,
      active: true
    });
  }
  if (tower.type == CANNON) {
    bullets.push({
      x: tower.x + tower.w/2, 
      y: tower.y + tower.h/2, 
      dx: 0, 
      dy: 0, 
      w: BOXWH/3, 
      h: BOXWH/3,
      twr: tower,
      active: true
    });
  }


  updateBullet(bullets[bullets.length-1], position);
}

function updateBullet(bullet, position) {
  //const AVERAGESPEED = 3; // AVG == 2 --> 1.95 is what it comes out to, keep in mind
  if (bullet.x < XOFFSET || bullet.x > XOFFSET + GAMEWIDTH) {
    bullet.active = false;
  }
  if (bullet.y < YOFFSET || bullet.y > YOFFSET + GAMEHEIGHT) {
    bullet.active = false;
  }

  var AVERAGESPEED = 1;
  if (bullet.twr.type == GUNNER) {
    AVERAGESPEED = GUNNERSPEED;
  }
  else if (bullet.twr.type == CANNON) {
    AVERAGESPEED = CANNONSPEED;
  }
  
  var changeX = (position.x+position.w/2-bullet.x);
  var changeY = (position.y+position.w/2-bullet.y);

  changeX /=100;
  changeY /=100;


  while (changeX < AVERAGESPEED && changeY < AVERAGESPEED && changeX > 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY > -AVERAGESPEED && changeX < 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY < AVERAGESPEED && changeX < 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX < AVERAGESPEED && changeY > -AVERAGESPEED && changeX > 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > AVERAGESPEED || changeY > AVERAGESPEED || changeX < -AVERAGESPEED || changeY < -AVERAGESPEED) {
    changeX /= 1.05;
    changeY /= 1.05;
  }
  if (bullet.active) {
    bullet.dx = changeX;
    bullet.dy = changeY;
  }

}



canvas.addEventListener('click', function(event) {
  var mousePos = getMousePos(canvas, event);
  //addBullet(mousePos, towers[towers.length-1]);
  var selectedButton = isInside(mousePos, buttons);
  if (selectedButton == null) {
    return;
  }
  if (selectedButton == nextWaveButton) {
    if (enemies.length == 0) {
      bullets = [];
      waveCount+=1;
      if (waveCount < waves.length) {
        generateWave(waves[waveCount]);
      }
      else {
        generateWave({arr: [10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5), 10*(waveCount/5)], waveNum: waveCount});
      }

    }
  }
}, false);

//HELPER FUNCTIONS

function Timer() { // game timer
  seconds+=.15;
    for (let x = 0; x < bullets.length; x++) {
      if (bullets[x] == null) {
        continue;
      }
        if (enemies[bullets[x].twr.target] != null) {
          if (enemies[bullets[x].twr.target].active) {
            updateBullet(bullets[x], enemies[bullets[x].twr.target]);
          }

        }
        if (bullets[x].twr.type == GUNNER) {
          var hitEnemy = isInside({x: bullets[x].x, y: bullets[x].y}, enemies);
          if (hitEnemy != null) {
            bullets[x] = null;
            hitEnemy.health--;
          }
        }
        else if (bullets[x].twr.type == CANNON) {
          var check = isInsideCannon({x: bullets[x].x, y: bullets[x].y}, enemies);
          if (check != null) {
            bullets[x] = null;
          }
          
        }


      }    
}



function clean() {
  var filtered = bullets.filter(function (el) {
  return el != null;
  });
  bullets = filtered;
  var filtered = enemies.filter(function (el) {
  return el != null;
  });
  enemies = filtered;
}


</script>


</html>