<!DOCTYPE html>
<link href="https://fonts.cdnfonts.com/css/arcade-classic" rel="stylesheet">
<title>Tower Defense</title>
<body>
<body style="background-color:white;">
  <canvas id="myCanvas" width='800' height='800' style="background-color:#d4f6ff"></canvas>
</body>
<style>

canvas {
    padding: 0;
    margin: auto;
    display: block;
    width: 800px;
    height: 800px;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    font-family: 'ArcadeClassic', sans-serif;
}
@import url('https://fonts.cdnfonts.com/css/arcade-classic');
                        
</style>
                
<script>
(function() {
  var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  window.requestAnimationFrame = requestAnimationFrame;
})();
// INITIALIZING ALL NECESSARY VARIABLES
var canvas = document.getElementById("myCanvas");
var c = canvas.getContext("2d");
c.font = "30px ArcadeClassic";

var enemies = [
  {x: 0, y: 0, w: 80, h: 80, speed: 1,color: "green", current: 0, pixel: 0},
  {x: 0, y: 0, w: 80, h: 80, speed: 3,color: "blue", current: 0, pixel: 0},
  {x: 0, y: 0, w: 80, h: 80, speed: 4,color: "red", current: 0, pixel: 0}
];
console.log("THIS GUY STIIINKS");
const level1 = [
1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 
0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 
1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 
1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 
1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 
1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 
0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 
1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 
1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 
1, 1, 1, 1, 1, 0, 1, 0, 0, 0];
const level1SS = [0,0];

const level2 = [
1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 
1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 
1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 
1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 
1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 
1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 
1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 
1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 
1, 1, 1, 1, 1, 0, 1, 1, 1, 0]; // top left is 0,0 btm right is 9,9
var level2SS = [0,0];

const level3 = [
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 1, 1, 1, 1, 1];
var level3SS = [0,0];

const level4 = [
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var level4SS = [0,0];




var selectedLevelMap = level1;
var startingSquare = level1SS;




/*
0  1  2  3  4  5  6  7  8  9
*/
// USE https://gube.live/pingu/grid-template/
var instances = 0;

  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (selectedLevelMap[i] == 1) {
      instances++;
    }
  }


var pathCoords = [];
var pathFound = false;
var startCoord = null;
var previous = [];
var tracker = 0;
var lockedPath = "NONE";
function pathFind(selectedLevelMap, startSq) {
  while (!pathFound) {
    if (startCoord == null) {
      previous = [startSq[0], startSq[1]];
      startCoord = previous;
      pathCoords.push(previous);
      continue;
    }
    tracker = previous[0] + previous[1] * 10;
    // LOOK UP
    if (pathCoords.length == instances) {
      pathFound = true;
      break;
    }
    if (tracker > 9) {
      if (lockedPath != "UP") {
        if (selectedLevelMap[tracker - 10] == 1) {
          previous = [tracker % 10, previous[1] - 1];
          pathCoords.push(previous);
          lockedPath = "DOWN";
          continue;
        }
      }
    }
    if (tracker < 90) {  // LOOK DOWN
      if (lockedPath != "DOWN") {
        if (selectedLevelMap[tracker + 10] == 1) {
          previous = [tracker % 10, previous[1] + 1];
          pathCoords.push(previous);
          lockedPath = "UP";
          continue;
        }
      }

    }  // LOOK LEFT
    if (tracker % 10 != 0) {
      if (lockedPath != "LEFT") {
        if (selectedLevelMap[tracker - 1] == 1) {
          previous = [tracker % 10 - 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "RIGHT";
          continue;
        }
      }

    }
    if (tracker % 10 != 9) {  // LOOK RIGHT
      if (lockedPath != "RIGHT") {
        if (selectedLevelMap[tracker + 1] == 1) {
          previous = [tracker % 10 + 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "LEFT";
          continue;
        }
      }

    }


  }
}
pathFind(level1, level1SS);

  /*////////////////////////////////
  ---------------MAIN---------------
  */////////////////////////////////
function drawTower(x, y, width, height) {
    c.fillStyle = "red";
    c.fillRect(x, y, width, height);
    requestAnimationFrame(drawTower);
}
var coords = [];
var directions = [];
var rows = 10;
var currentRow = 0;
for (let i = 0; i < selectedLevelMap.length; i++) {
  if (i != 0 && i % rows == 0) {
      console.log(i);
      currentRow++;
    }
    coords.push({
      x: (i % rows)*80,
      y: (currentRow)*80,
      w: 80,
      h: 80,
      value: selectedLevelMap[i],
      rx: i % 10,
      ry: currentRow
    });
    //c.fillRect((i % rows)*80, (currentRow)*80, 80, 80);
  }

for (let i = 0; i < pathCoords.length; i++) {
  for (let x = 0; x < coords.length; x++) {
    if (pathCoords[i][0] == coords[x].rx && pathCoords[i][1] == coords[x].ry) {
      directions.push(coords[x]);
      continue;
    }
  }
}




function drawBullet(x, y, dx, dy, width, height) {
  c.clearRect(x, y, width, height);
  c.fillStyle = "green";
  c.fillRect(x, y, width, height);
  x += dx;
  y += dy;
  requestAnimationFrame(drawBullet);
}

function drawBackground() {
  currentRow = 0;
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % rows == 0) {
      currentRow++;
    }
    if (selectedLevelMap[i] == 0) {
      c.fillStyle = "black";
    }
    else {
      c.fillStyle = "white";
    }
    c.fillRect((i % rows)*80, (currentRow)*80, canvas.width / rows, canvas.height / rows);
  }
  requestAnimationFrame(drawBackground);
}
drawBackground();

drawTower(40, 80, 40, 40);
drawBullet(55, 95, 1, 1, 10, 10)

function drawEnemies() {
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    c.fillStyle = enemies[i].color;
    c.fillRect(enemies[i].x, enemies[i].y, enemies[i].w, enemies[i].h);
  }
  window.requestAnimationFrame(drawEnemies);
}

function moveEnemies() {
  if (directions.length == 0) {
        return;
      }
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current == directions.length) {
      enemies[i] = null;
      continue;
    }
    if (enemies[i].current == 0) {
      if (directions.length > 0) {
        enemies[i].x = directions[1].x;
        enemies[i].y = -80 + enemies[i].pixel;
      }
    }
    else {
        if (directions[enemies[i].current].x < directions[enemies[i].current+1].x) {
          enemies[i].x+=enemies[i].speed;

        }
        else if (directions[enemies[i].current].x > directions[enemies[i].current+1].x) {
          enemies[i].x-=enemies[i].speed;

        }
        else if (directions[enemies[i].current].y < directions[enemies[i].current+1].y) {
          enemies[i].y+=enemies[i].speed;

        }
        else if (directions[enemies[i].current].y > directions[enemies[i].current+1].y) {
          enemies[i].y-=enemies[i].speed;

        }

    }

    enemies[i].pixel+=enemies[i].speed;


    if (enemies[i].pixel >= 80) {
      enemies[i].current++;
      if (enemies[i].current == directions.length-1) {
        enemies[i] = null;
        continue;
      }
        if (directions.length > 0 && enemies[i].current < directions.length) {
          enemies[i].x = directions[enemies[i].current].x;
          enemies[i].y = directions[enemies[i].current].y;
        }

        enemies[i].pixel = 0;
      }

  }
  window.requestAnimationFrame(moveEnemies);
}
drawEnemies();
moveEnemies();

function Timer() { // game timer
    seconds+=.15;

}

console.log(coords);

//HELPER FUNCTIONS
function Timer() { // game timer
  seconds+=.15;
}

function getRandomIntInclusive(min, max) { // random function for ghost movement, returns integers
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive
}

function isInside(pos, arr) {
  for (let i =0; i < arr.length; i++) {
    if (arr[i] != null) {
      if (pos.x > arr[i].x && pos.x < arr[i].x + arr[i].w && pos.y < arr[i].y + arr[i].h && pos.y > arr[i].y) {
        return arr[i];
      }
    }
  }
  return null;
}

function getMousePos(canvas, event) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  };
}

function randomN(lower, upper) { // random num gen from min to max (inclusive), returns floats
  return Math.random() * (upper - lower) + lower;
}

//EVENT LISTENERS
canvas.addEventListener("mousemove", function (event) {
}, false);

canvas.addEventListener('click', function(event) {
}, false);
</script>


</html>

