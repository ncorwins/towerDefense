
<!DOCTYPE html>
<head>
  <meta name = "viewport" content = "width=device-width, initial-scale=1.0">
  <link href="https://fonts.cdnfonts.com/css/arcade-classic" rel="stylesheet">
<title>Tower Defense</title>
<link rel="icon" href="images/cannon/cannonball.png">
<style>

canvas {
    padding: 0;
    margin: auto;
    display: block;
    width: 1300px;
    height: 900px;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    font-family: 'ArcadeClassic', sans-serif;
}
@import url('https://fonts.cdnfonts.com/css/arcade-classic');
                        
</style>
</head>
<body style="background-color:#000000;">
  <canvas id="myCanvas" width='1300' height='900' style="background-color:#000000"></canvas>
</body>   
<script>
(function() {
  var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  window.requestAnimationFrame = requestAnimationFrame;
})();
// INITIALIZING ALL NECESSARY VARIABLES
var canvas = document.getElementById("myCanvas");
var c = canvas.getContext("2d");
c.font = "30px ArcadeClassic";
c.imageSmoothingEnabled = false;
const NUMCOLS = 15;
const NUMROWS = 10;
const BOXWH = 60;
const GAMEWIDTH = BOXWH*NUMCOLS;
const GAMEHEIGHT = BOXWH*NUMROWS;

const XOFFSET = (canvas.width-GAMEWIDTH)/2;
const YOFFSET = (canvas.height-GAMEHEIGHT)/2;

// GAMEPLAY MECHANICS
const GAMESPEED = .25;

const GUNNERSPEED = 5*GAMESPEED;
const GUNNERFIRERATE = 100*(1/GAMESPEED);


const CANNONRANGE = 20;
const CANNONSPEED = 3*GAMESPEED;
const CANNONFIRERATE = 700*(1/GAMESPEED);

var SNIPERPIERCE = 5;
const SNIPERSPEED = 30*GAMESPEED;
const SNIPERFIRERATE = 500*(1/GAMESPEED);

const ENEMYSIZE = 70;

var blast0 = new Image();
blast0.src = "images/blast/pixil-frame-0.png";
var blast1 = new Image();
blast1.src = "images/blast/pixil-frame-1.png";
var blast2 = new Image();
blast2.src = "images/blast/pixil-frame-2.png";
var blast3 = new Image();
blast3.src = "images/blast/pixil-frame-3.png";
var blast4 = new Image();
blast4.src = "images/blast/pixil-frame-4.png";

var blastImages = [blast0, blast1, blast2, blast3, blast4];
var blastFrames = [];
var selectedTower = null;

var waveCount = 0;

var emptyblank = new Image();
emptyblank.src = "images/greyblank.png";

var emptyGunner = new Image();
emptyGunner.src = "images/gunner/empty.png";
var gunnerImage = new Image();
gunnerImage.src = "images/gunner/tower.png";
var gunnerball = new Image();
gunnerball.src = "images/gunner/gunnerball.png";


var emptyCannon = new Image();
emptyCannon.src = "images/cannon/empty.png";
var cannonImage = new Image();
cannonImage.src = "images/cannon/cannon.png";
var cannonball = new Image();
cannonball.src = "images/cannon/cannonball.png";

var sniperImage = new Image();
sniperImage.src = "images/sniper/SniperImage.png";
var emptySniper = new Image();
emptySniper.src = "images/sniper/emptySniper.png";

var backG = new Image();
backG.src = "images/backgtd2.png";

var upgradeBackground = new Image();
upgradeBackground.src = "images/UpgradeImages/pixil-frame-0.png";
var upgradeArrowHoverImage = new Image();
upgradeArrowHoverImage.src = "images/UpgradeImages/pixil-frame-1.png";
var upgradeBar0 = new Image();
upgradeBar0.src = "images/UpgradeImages/pixil-frame-2.png";
var upgradeBar1 = new Image();
upgradeBar1.src = "images/UpgradeImages/pixil-frame-3.png";
var upgradeBar2 = new Image();
upgradeBar2.src = "images/UpgradeImages/pixil-frame-4.png";
var upgradeBar3 = new Image();
upgradeBar3.src = "images/UpgradeImages/pixil-frame-5.png";
var upgradeBar4 = new Image();
upgradeBar4.src = "images/UpgradeImages/pixil-frame-6.png";
var upgradeArrowImage = new Image();
upgradeArrowImage.src = "images/UpgradeImages/pixil-frame-7.png";
var upgradesImagesArr = [upgradeBar0, upgradeBar1, upgradeBar2, upgradeBar3, upgradeBar4];
var upgradeArrowButton0 = {
  x: 0,
  y: 0, 
  w: 40,
  h: 30,
  ind: 0,
  hover: false
}
var upgradeArrowButton1 = {
  x: 0,
  y: 0, 
  w: 40,
  h: 30,
  ind: 1,
  hover: false
}
var upgradeArrowButton2 = {
  x: 0,
  y: 0, 
  w: 40,
  h: 30,
  ind: 2,
  hover: false
}
var arrowButtons = [upgradeArrowButton0, upgradeArrowButton1, upgradeArrowButton2];


var enemies = [
];
const level1 = [
1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 
1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 
1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 
1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 
1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];
const level1SS = [0,0];

var seconds = 0;
var towers = []
var GUNNER = "gunner";
var CANNON = "cannon";
var SNIPER = "sniper";

var bullets = []
const TOWEROFFSETX = 72;
const TOWEROFFSETY = 110;

var heroButtons = [{
  type: GUNNER,
  x: 41, 
  y: 209, 
  w: BOXWH,
  h: BOXWH,
  imgs: [emptyblank, gunnerImage],
  real: emptyGunner,
  bullet: gunnerball,
  price: 200,
  damage: 1,
  kills: 0,
  totalDamageApplied: 0,
  speed: 5*GAMESPEED,
  pierce: 1,
  upgradeLevel0: 0,
  upgradeLevel1: 0,
  upgradeLevel2: 0
},
  {
  type: CANNON,
  x: 41+TOWEROFFSETX, 
  y: 209, 
  w: BOXWH,
  h: BOXWH,
  imgs: [emptyblank, cannonImage],
  real: emptyCannon,
  bullet: cannonball,
  price: 300,
  damage: 5,
  kills: 0,
  totalDamageApplied: 0,
  speed: 3*GAMESPEED,
  pierce: 1,
  upgradeLevel0: 0,
  upgradeLevel1: 0,
  upgradeLevel2: 0
},
  {
  type: SNIPER,
  x: 41, 
  y: 209+TOWEROFFSETY, 
  w: BOXWH,
  h: BOXWH,
  imgs: [emptyblank, sniperImage],
  real: emptySniper,
  bullet: "red",
  price: 500,
  damage: 10,
  kills: 0,
  totalDamageApplied: 0,
  speed: 30*GAMESPEED,
  pierce: 5,
  upgradeLevel0: 0,
  upgradeLevel1: 0,
  upgradeLevel2: 0
}]

var selectedLevelMap = level1;
var startingSquare = level1SS;




/*
0  1  2  3  4  5  6  7  8  9
*/
// USE https://gube.live/pingu/grid-template/
var instances = 0;
function calcInstances() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (selectedLevelMap[i] == 1) {
      instances++;
    }
  }
}
calcInstances();

function playHit() { // for playing poof sound
    var audio = new Audio();
    audio.src = "sounds/hit.mp3";
    audio.volume = .005;
    audio.currentTime = 0; // Reset audio to start
    audio.play();

}
function playCannon() { // for playing poof sound
    var audio = new Audio();
    audio.src = "sounds/cannon.mp3";
    audio.volume = .005;
    audio.currentTime = 0; // Reset audio to start
    audio.play();
}
function playClick() { // for playing poof sound
    var audio = new Audio();
    audio.src = "sounds/click.m4a";
    audio.volume = .05;
    audio.currentTime = 1; // Reset audio to start
    audio.play();
}

var start0 = new Image();
start0.src = "images/startButton/pixil-frame-0.png";
var start1 = new Image();
start1.src = "images/startButton/pixil-frame-1.png";

var flesh = new Image();
flesh.src = "images/flesh23.png";

var nextWaveButton = {
  x: canvas.width/2-150/2,
  y: 50,
  w: 150,
  h: 50,
  imgs: [start0, start1],
  hover: false,
  index: 0
};
var buttons = [nextWaveButton];


var redEI = new Image();
redEI.src = "images/enemies/pixil-frame-0.png";
var blueEI = new Image();
blueEI.src = "images/enemies/pixil-frame-1.png";
var greenEI = new Image();
greenEI.src = "images/enemies/pixil-frame-2.png";
var grayEI = new Image();
grayEI.src = "images/enemies/pixil-frame-3.png";
var brownEI = new Image();
brownEI.src = "images/enemies/pixil-frame-4.png";
var pinkEI = new Image();
pinkEI.src = "images/enemies/pixil-frame-5.png";
var limeEI = new Image();
limeEI.src = "images/enemies/pixil-frame-6.png";
var aquaEI = new Image();
aquaEI.src = "images/enemies/pixil-frame-7.png";
var orangeEI = new Image();
orangeEI.src = "images/enemies/pixil-frame-8.png";
var purpleEI = new Image();
purpleEI.src = "images/enemies/pixil-frame-9.png";

var rocketTypes = [
  {
    desc: "red, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: redEI,
    current: 0, 
    pixel: 0, 
    health: 1, 
  },
  {
    desc: "blue, FAST",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 4*GAMESPEED, 
    color: blueEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "green, SLOW CHUNKY BOY",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: greenEI,
    current: 0, 
    pixel: 0,
    health: 6, 
  },
  {
    desc: "gray, FAST AND CHUNKY",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 3*GAMESPEED, 
    color: grayEI,
    current: 0, 
    pixel: 0,
    health: 4, 
  },  
  {
    desc: "brown, slow and bad",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: brownEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "pink, dies spawns more",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1*GAMESPEED, 
    color: pinkEI,
    current: 0, 
    pixel: 0,
    health: 1, 
  },
  {
    desc: "lime, TANKY, medium speed",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 1.6*GAMESPEED, 
    color: limeEI,
    current: 0, 
    pixel: 0, 
    health: 20, 
  },
  {
    desc: "aqua, OG",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: aquaEI,
    current: 0, 
    pixel: 0, 
    health: 2, 
  },
  {
    desc: "orange, EXPLODE 50",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: .5*GAMESPEED, 
    color: orangeEI,
    current: 0, 
    pixel: 0, 
    health: 31, 
  },
  {
    desc: "purple, EXPLODE 25",
    dir: 1, 
    x: XOFFSET, 
    y: YOFFSET, 
    w: BOXWH, 
    h: BOXWH, 
    speed: 2*GAMESPEED, 
    color: purpleEI,
    current: 0, 
    pixel: 0,
    health: 21,
  }
]

var waves = [
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       0,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 0
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 1
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 2
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      0,      0,      0,      0,       0,       0],
    waveNum: 3
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      10,      0,      1,      0,       0,       0],
    waveNum: 4
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      0,       10,      10,      0,      3,      5,       0,       0],
    waveNum: 5
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       0,      0,       0,      0,      0,      8,      5,       0,       0],
    waveNum: 6
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      0,      0,      5,       0,       0],
    waveNum: 7
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       0,      0,      2,      10,      10,       0,       0],
    waveNum: 8
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [10,       10,      10,       10,      10,      3,      10,      10,       0,       0],
    waveNum: 9
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      4,      20,      15,       0,       0],
    waveNum: 10
  }, 
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [100,       0,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 12
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [50,       50,      0,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 13
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [50,       50,      50,       0,      0,      0,      0,      0,       0,       0],
    waveNum: 14
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       40,      0,      0,      0,      0,       0,       0],
    waveNum: 15
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
      arr: 
    [0,       0,      0,       40,      0,      0,      0,      0,       0,       0],
    waveNum: 16
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      150,      0,      0,      0,       0,       0],
    waveNum: 17
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      75,      0,       0,       0],
    waveNum: 18
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      200,       0,       0],
    waveNum: 19
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      5,      0,      0,       0,       0],
    waveNum: 20
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      15,      0,      0,       0,       0],
    waveNum: 21
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       0,       5],
    waveNum: 22
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       0,       10],
    waveNum: 23
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       0,       15],
    waveNum: 24
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       1,       0],
    waveNum: 25
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       3,       0],
    waveNum: 26
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [0,       0,      0,       0,      0,      0,      0,      0,       5,       0],
    waveNum: 27
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      5,      20,      15,       1,       3],
    waveNum: 28
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      10,      20,      15,       1,       5],
    waveNum: 29
  },
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      0,      20,      15,       2,       0],
    waveNum: 30
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      5,      20,      15,       2,       3],
    waveNum: 31
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      5,      20,      15,       3,       5],
    waveNum: 32
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [15,       15,      15,       15,      15,      10,      20,      15,       5,       10],
    waveNum: 33
  },  
  {//redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI
    arr: 
    [50,       50,      50,       50,      50,      10,      25,      50,       10,       15],
    waveNum: 34
  }
]

var colorArr = [redEI, blueEI, greenEI, grayEI, brownEI, pinkEI, limeEI, aquaEI, orangeEI, purpleEI];
var pathCoords = [];
var pathFound = false;
var startCoord = null;
var previous = [];
var tracker = 0;
var lockedPath = "NONE";
var tmp = null;
var coords = [];
var directions = [];
var currentRow = 0;
var balance = 600;

function pathFind(selectedLevelMap, startSq) {
  while (!pathFound) {
    if (startCoord == null) {
      previous = [startSq[0], startSq[1]];
      startCoord = previous;
      pathCoords.push(previous);
      continue;
    }
    tracker = previous[0] + previous[1] * NUMCOLS;
    // LOOK UP

    if (pathCoords.length == instances) {
      pathFound = true;
      break;
    }
    if (tracker > NUMCOLS-1) {
      if (lockedPath != "UP") {
        if (selectedLevelMap[tracker - NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] - 1];
          pathCoords.push(previous);
          lockedPath = "DOWN";
          continue;
        }
      }
    }

    if (tracker < NUMCOLS*(NUMROWS-1)) {  // LOOK DOWN
      if (lockedPath != "DOWN") {
        if (selectedLevelMap[tracker + NUMCOLS] == 1) {
          previous = [tracker % NUMCOLS, previous[1] + 1];
          pathCoords.push(previous);
          lockedPath = "UP";
          continue;
        }
      }

    }  // LOOK LEFT
    if (tracker % NUMCOLS != 0) {
      if (lockedPath != "LEFT") {
        if (selectedLevelMap[tracker - 1] == 1) {
          previous = [tracker % NUMCOLS - 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "RIGHT";
          continue;
        }
      }

    }

    if (tracker % NUMCOLS != NUMCOLS-1) {  // LOOK RIGHT
      if (lockedPath != "RIGHT") {
        if (selectedLevelMap[tracker + 1] == 1) {
          previous = [tracker % NUMCOLS + 1, previous[1]];
          pathCoords.push(previous);
          lockedPath = "LEFT";
          continue;
        }
      }

    }


  }
}

function drawTowers() {
    c.fillStyle = "red";

    for (let i = 0; i < towers.length; i++) {
      c.drawImage(towers[i].real, towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      c.font = "12px ArcadeClassic";
      if (towers[i].totalDamageApplied < 0) {
        towers[i].totalDamageApplied = 0;
      }
      drawStroked(towers[i].totalDamageApplied, towers[i].x+8, towers[i].y+12);
      //c.drawImage(towers[i].imgs[1], towers[i].x, towers[i].y, towers[i].w, towers[i].h);
      var angle = ((Math.atan2(towers[i].dy, towers[i].dx) * 180) / Math.PI);
      drawRotated(Math.round(angle+90), towers[i]); // angle + 90 since we start at pi/2
    }
    for (let i = 0; i < blastFrames.length; i++) {
      if (blastFrames[i] != null) {
        c.drawImage(blastImages[blastFrames[i].frame], blastFrames[i].x, blastFrames[i].y);
      }

    }

  window.requestAnimationFrame(drawTowers);
}

function drawRotated(degrees, tower){ // draw  a tower with rotation
    //c.clearRect(0,0,canvas.width,canvas.height);

    // save the unrotated context of the canvas so we can restore it later
    // the alternative is to untranslate & unrotate after drawing
    c.save();

    // move to the center of the canvas
    c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

    // rotate the canvas to the specified degrees
    c.rotate(degrees*Math.PI/180);

    // draw the image
    // since the context is rotated, the image will be rotated also
    c.drawImage(tower.imgs[1], -tower.w/2,-tower.h/2, tower.w, tower.h);

    // were done with the rotating so restore the unrotated context
    c.restore();
}

function drawRotatedEnemies(degrees, tower) {
  c.save();

  // move to the center of the canvas
  c.translate(tower.x+tower.w/2, tower.y+tower.h/2);

  // rotate the canvas to the specified degrees
  c.rotate(degrees*Math.PI/180);

  // draw the image
  // since the context is rotated, the image will be rotated also
  c.drawImage(tower.color, -ENEMYSIZE/2,-ENEMYSIZE/2, ENEMYSIZE, ENEMYSIZE);

  // weâ€™re done with the rotating so restore the unrotated context
  c.restore();
}

function createDirections() {
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
        currentRow++;
      }
      coords.push({
        x: XOFFSET + (i % NUMCOLS)*BOXWH,
        y: YOFFSET + (currentRow)*BOXWH,
        w: BOXWH,
        h: BOXWH,
        value: selectedLevelMap[i],
        rx: i % NUMCOLS,
        ry: currentRow
      });
      //c.fillRect((i % rows)*60, (currentRow)*60, 60, 60);
    }

  for (let i = 0; i < pathCoords.length; i++) {
    for (let x = 0; x < coords.length; x++) {
      if (pathCoords[i][0] == coords[x].rx && pathCoords[i][1] == coords[x].ry) {
        directions.push(coords[x]);
        continue;
      }
    }
  }

}

function drawBullets() {
  clean();

  for (let i = 0; i < bullets.length; i++) {
    if (bullets[i].twr.type == GUNNER) {
      c.fillStyle = "green";
      c.beginPath();
      c.arc(bullets[i].x + bullets[i].w/2, bullets[i].y + bullets[i].h/2, 5, 0, Math.PI * 2);
      c.closePath();
      c.fill();
      //c.drawImage(bullets[i].twr.bullet, bullets[i].x, bullets[i].y, bullets[i].w*2, bullets[i].h*2);
    }
    else if (bullets[i].twr.type == SNIPER) {
      c.fillStyle = "red";
      c.beginPath();
      c.arc(bullets[i].x + bullets[i].w/2, bullets[i].y + bullets[i].h/2, 3, 0, Math.PI * 2);
      c.closePath();
      c.fill();
    }
    else if (bullets[i].twr.type == CANNON) {
      //drawRotatedCannon(seconds*60 % 365, bullets[i]);
      c.drawImage(cannonball, bullets[i].x,bullets[i].y, bullets[i].w*2, bullets[i].h*2);
    }
      bullets[i].x += bullets[i].dx;
      bullets[i].y += bullets[i].dy;
      if (bullets[i].x < 0-bullets[i].w || bullets[i].x > canvas.width || bullets[i].y < 0-bullets[i].h || bullets[i].y > canvas.height) {
        bullets[i] = null;
      }
  }


  window.requestAnimationFrame(drawBullets);
}

function drawBackground() {


  c.clearRect(0,0,canvas.width, canvas.height);
  currentRow = 0;
  for (let i = 0; i < selectedLevelMap.length; i++) {
    if (i != 0 && i % NUMCOLS == 0) {
      currentRow++;
    }
    if (selectedLevelMap[i] == 0) {
      c.fillStyle = "black";
    }
    else {
      c.fillStyle = "white";
    }
    c.fillRect(XOFFSET + (i % NUMCOLS)*BOXWH, YOFFSET + (currentRow)*BOXWH, GAMEWIDTH / NUMCOLS, GAMEHEIGHT / NUMROWS);
  }
  c.drawImage(flesh, 0, 0, canvas.width, canvas.height);
  c.drawImage(backG, XOFFSET, YOFFSET, GAMEWIDTH, GAMEHEIGHT);
  window.requestAnimationFrame(drawBackground);
}

function drawEnemies() {
  clean();
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].x+enemies[i].w/2-10 >= XOFFSET) {
      enemies[i].active = true;
      drawRotatedEnemies((enemies[i].dir-1)*90, enemies[i]);
      //c.drawImage(enemies[i].color, enemies[i].x, enemies[i].y, enemies[i].w, enemies[i].h);
    }

  }
  window.requestAnimationFrame(drawEnemies);
}

function moveEnemies() {
  clean();
  if (directions.length == 0) {
        return;
      }
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].x < XOFFSET) {
      enemies[i].x+=enemies[i].speed;
      continue;
    }
    if (enemies[i].health <= 0) {
      balance+=2;
      if (enemies[i].color == pinkEI) {
        generateEnemies(10, enemies[i]);
        //clean();
      }
      if (enemies[i].color == purpleEI) {
        generateEnemies(25, enemies[i]);
      }
      if (enemies[i].color == orangeEI) {
        generateEnemies(50, enemies[i]);
      }
      enemies[i] = null;
    }
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current == directions.length) {
      enemies[i] = null;
      continue;
    }
    if (enemies[i].current < directions.length-1) {
      if (directions[enemies[i].current].x < directions[enemies[i].current+1].x) {
          enemies[i].x+=enemies[i].speed;
          enemies[i].dir = 1;

        }
        else if (directions[enemies[i].current].x > directions[enemies[i].current+1].x) {
          enemies[i].x-=enemies[i].speed;
          enemies[i].dir = 3;
        }
        else if (directions[enemies[i].current].y < directions[enemies[i].current+1].y) {
          enemies[i].y+=enemies[i].speed;
          enemies[i].dir = 2;

        }
        else if (directions[enemies[i].current].y > directions[enemies[i].current+1].y) {
          enemies[i].y-=enemies[i].speed;
          enemies[i].dir = 0;
        }
    }


    enemies[i].pixel+=enemies[i].speed;



    if (enemies[i].pixel >= BOXWH) {
      enemies[i].current++;
      if (enemies[i].current == directions.length-1) {
        enemies[i] = null;
        continue;
      }
        if (directions.length > 0 && enemies[i].current < directions.length) {
          enemies[i].x = directions[enemies[i].current].x;
          enemies[i].y = directions[enemies[i].current].y;
        }

        enemies[i].pixel = 0;
      }

  }
  window.requestAnimationFrame(moveEnemies);
}

function drawStroked(text, x, y) {
    c.strokeStyle = 'black';
    c.lineWidth = 3;
    c.strokeText(text, x, y);
    c.fillStyle = 'white';
    c.fillText(text, x, y);
}

function drawHeroButtons() {
  const textOffsetX = 30;
  const textOffsetY = 75;
  c.textAlign = "center";
  c.font = "15px ArcadeClassic";
  for (let i = 0; i < heroButtons.length; i++) {
    for (let x = 0; x < heroButtons[i].imgs.length; x++) {
      if (x == 0) {
        if (balance >= heroButtons[i].price) {
          c.drawImage(heroButtons[i].real, heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
        }
        else {
          c.drawImage(heroButtons[i].imgs[x], heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
        }
      }
      else {
        c.drawImage(heroButtons[i].imgs[x], heroButtons[i].x, heroButtons[i].y, heroButtons[i].w, heroButtons[i].h);
      }
      c.fillStyle = "white";
      drawStroked("$  " + heroButtons[i].price, heroButtons[i].x+textOffsetX, heroButtons[i].y+textOffsetY)
    }
  }
  if (tmp != null) {
    for (let x = 0; x < tmp.imgs.length; x++) {
      c.drawImage(tmp.imgs[x], tmp.x, tmp.y, tmp.w, tmp.h);
    }
  }
  c.font = "25px ArcadeClassic";
  drawStroked("Balance:   $ " + balance, GAMEWIDTH+XOFFSET, YOFFSET-50);
  drawStroked("Wave   " + waveCount + "/35", GAMEWIDTH+XOFFSET, YOFFSET-20)
  window.requestAnimationFrame(drawHeroButtons);
}

function generateEnemies(numOfEnemies, enemy = {x: -1, y: 0}) { // generation for pink
  for (let i = 0; i < numOfEnemies; i++) {
    var rand = getRandomIntInclusive(0, rocketTypes.length-1);
    var SoffSet = (1)*((numOfEnemies-i)/numOfEnemies) + .25;
    enemies.push({
      desc: rocketTypes[rand].desc,
      dir: rocketTypes[rand].dir, 
      x: XOFFSET, 
      y: YOFFSET, 
      w: BOXWH, 
      h: BOXWH, 
      speed: rocketTypes[rand].speed+SoffSet, 
      color: rocketTypes[rand].color,
      current: rocketTypes[rand].current, 
      pixel: rocketTypes[rand].pixel,
      health: rocketTypes[rand].health, 
      active: false
    });
    if (enemy.x != -1) {
      while (enemies[enemies.length-1].color == pinkEI || enemies[enemies.length-1].color == purpleEI || enemies[enemies.length-1].color == orangeEI) {
        var rand = getRandomIntInclusive(0, rocketTypes.length-1);
        enemies[enemies.length-1] = ({
          desc: rocketTypes[rand].desc,
          dir: enemy.dir, 
          x: enemy.x, 
          y: enemy.y, 
          w: BOXWH, 
          h: BOXWH, 
          speed: rocketTypes[rand].speed+SoffSet, 
          color: rocketTypes[rand].color,
          current: enemy.current, 
          pixel: rocketTypes[rand].pixel,
          health: rocketTypes[rand].health,
          active: false
        });
      }
      enemies[enemies.length-1].x = enemy.x;
      enemies[enemies.length-1].y = enemy.y;
      enemies[enemies.length-1].dir =  enemy.dir;
      enemies[enemies.length-1].current = enemy.current;

    }


  } // dir: 0 --> UP,   1 --> RIGHT,   2 --> DOWN,   3 --> LEFT
}

function countRockets(wave) {
  var total = 0;
  for (let i = 0; i < wave.arr.length; i++) {
    total+=wave.arr[i];
  }
  return total;
}

function generateWave(wave) { // main generation func
  var rocketCount = countRockets(wave);
  var SoffSet = 0;
  for (let i = 0; i < wave.arr.length; i++) {
    for (let x = 0; x < wave.arr[i]; x++) {
      SoffSet+=1;
      enemies.push({
        desc: rocketTypes[i].desc,
        dir: rocketTypes[i].dir, 
        x: XOFFSET-90-SoffSet*4,
        y: YOFFSET, 
        w: BOXWH, 
        h: BOXWH, 
        speed: rocketTypes[i].speed, 
        color: rocketTypes[i].color,
        current: rocketTypes[i].current, 
        pixel: rocketTypes[i].pixel,
        health: rocketTypes[i].health,
        active: false 
      });
    }
  }
}

function shootGunner(tower) {
  clean();
  if (enemies.length == 0) {
    return;
  }
  var active = false;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].active) {
      active = true;
    }
  }
  if (active) {
    addBullet({x: 0, y: 0, w: 0, h: 0}, tower);
  }

}
function shootGunner_0() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == GUNNER) {
      if (towers[i].upgradeLevel0 == 0) {
        shootGunner(towers[i]);
      }
    }
  }
}
function shootGunner_1() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == GUNNER) {
      if (towers[i].upgradeLevel0 == 1) {
        shootGunner(towers[i]);
      }
    }
  }
}
function shootGunner_2() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == GUNNER) {
      if (towers[i].upgradeLevel0 == 2) {
        shootGunner(towers[i]);
      }
    }
  }
}
function shootGunner_3() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == GUNNER) {
      if (towers[i].upgradeLevel0 == 3) {
        shootGunner(towers[i]);
      }
    }
  }
}
function shootGunner_4() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == GUNNER) {
      if (towers[i].upgradeLevel0 == 4) {
        shootGunner(towers[i]);
      }
    }
  }
}









function shootSniper(tower) {
  clean();
  if (enemies.length == 0) {
    return;
  }
  var active = false;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].active) {
      active = true;
    }
  }
  if (active) {
    tower.kills = 0;
    addBullet({x: 0, y: 0, w: 0, h: 0}, tower);
  }
}
function shootSniper_0() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == SNIPER) {
      if (towers[i].upgradeLevel0 == 0) {
        shootSniper(towers[i]);
      }
    }
  }
}
function shootSniper_1() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == SNIPER) {
      if (towers[i].upgradeLevel0 == 1) {
        shootSniper(towers[i]);
      }
    }
  }
}
function shootSniper_2() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == SNIPER) {
      if (towers[i].upgradeLevel0 == 2) {
        shootSniper(towers[i]);
      }
    }
  }
}
function shootSniper_3() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == SNIPER) {
      if (towers[i].upgradeLevel0 == 3) {
        shootSniper(towers[i]);
      }
    }
  }
}
function shootSniper_4() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == SNIPER) {
      if (towers[i].upgradeLevel0 == 4) {
        shootSniper(towers[i]);
      }
    }
  }
}


function shootCannon(tower) {
  clean();
  if (enemies.length == 0) {
    return;
  }
  var active = false;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i].active) {
      active = true;
    }
  }
  if (active) {
    addBullet({x: 0, y: 0, w: BOXWH/2, h: BOXWH/2}, tower);
  }
}
function shootCannon_0() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == CANNON) {
      if (towers[i].upgradeLevel0 == 0) {
        shootCannon(towers[i]);
      }
    }
  }
}
function shootCannon_1() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == CANNON) {
      if (towers[i].upgradeLevel0 == 1) {
        shootCannon(towers[i]);
      }
    }
  }
}
function shootCannon_2() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == CANNON) {
      if (towers[i].upgradeLevel0 == 2) {
        shootCannon(towers[i]);
      }
    }
  }
}
function shootCannon_3() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == CANNON) {
      if (towers[i].upgradeLevel0 == 3) {
        shootCannon(towers[i]);
      }
    }
  }
}
function shootCannon_4() {
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].type == CANNON) {
      if (towers[i].upgradeLevel0 == 4) {
        shootCannon(towers[i]);
      }
    }
  }
}









function adjustTowers() { // updates target and tower dy dx
  var closestEnemy = -1;
  var maxNum = -1;
  for (let i = 0; i < enemies.length; i++) {
    if (enemies[i] == null) {
      continue;
    }
    if (enemies[i].current > maxNum) {
      closestEnemy = enemies[i];
      maxNum = enemies[i].current;
    }
  }
  for (let x = 0; x < towers.length; x++) {
    if (closestEnemy != -1) {
      towers[x].target = enemies.indexOf(closestEnemy);
      towers[x].dx = closestEnemy.x-towers[x].x;
      towers[x].dy = closestEnemy.y-towers[x].y;
    }
  }


}

function drawButtons() {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i] == nextWaveButton) {
      if (enemies.length == 0) {
        if (buttons[i].hover) {
          c.drawImage(buttons[i].imgs[1], buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h*3);
        }
        else {
          c.drawImage(buttons[i].imgs[0], buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h*3);
        }
      }
    }

  }

  window.requestAnimationFrame(drawButtons);
}

function animsUI() {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i] == nextWaveButton) {
      buttons[i].index += 1;
      buttons[i].index %= buttons[i].imgs.length;
    }
  }
}

function blastFramesFunction() {
  for (let i = 0; i < blastFrames.length; i++) {
    blastFrames[i].frame++;
    if (blastFrames[i].frame > 4) {
      blastFrames[i] = null;
    }
  }
}

function drawUpgrades() {
  // if click on tower and open upgrades
  if (towers.length > 0) {
    if (selectedTower != null) {
      const baseX = XOFFSET +GAMEWIDTH;
      const baseY = 400;
      const scale = 2;
      const BARYOFF = 30;
      const FBAROFF = -57;
      c.drawImage(upgradeBackground, baseX, baseY, 100*scale, 100*scale);
      c.drawImage(upgradesImagesArr[towers[selectedTower].upgradeLevel0], baseX, baseY+(BARYOFF+FBAROFF)*scale, 100*scale, 100*scale)
      c.drawImage(upgradesImagesArr[towers[selectedTower].upgradeLevel1], baseX, baseY+(BARYOFF*2+FBAROFF)*scale, 100*scale, 100*scale)
      c.drawImage(upgradesImagesArr[towers[selectedTower].upgradeLevel2], baseX, baseY+(BARYOFF*3+FBAROFF)*scale, 100*scale, 100*scale)
      const UP1 = {x: baseX,
        y: baseY+(BARYOFF+FBAROFF)*scale};
      for (let i = 0; i < arrowButtons.length; i++) {
        arrowButtons[i].x = UP1.x;
        arrowButtons[i].y = UP1.y + (i*BARYOFF*scale);
        if (arrowButtons[i].hover) {
          c.drawImage(upgradeArrowHoverImage, arrowButtons[i].x, arrowButtons[i].y, 100*scale, 100*scale);
        }
        else {
          c.drawImage(upgradeArrowImage, arrowButtons[i].x, arrowButtons[i].y, 100*scale, 100*scale);
        }
        arrowButtons[i].x+=75*scale;
        arrowButtons[i].y+=38*scale;
      }
      c.strokeStyle = "white";
      c.strokeRect(towers[selectedTower].x, towers[selectedTower].y, towers[selectedTower].w, towers[selectedTower].h);
    }
  }
  window.requestAnimationFrame(drawUpgrades);
}

pathFind(level1, level1SS);
createDirections();
drawBackground();
drawButtons();
drawHeroButtons();
drawBullets();
drawTowers();
drawEnemies();
moveEnemies();
drawUpgrades();
generateWave(waves[waveCount]);
waveCount++;



setInterval(shootSniper_0, SNIPERFIRERATE);
setInterval(shootSniper_1, SNIPERFIRERATE*(5/6));
setInterval(shootSniper_2, SNIPERFIRERATE*(4/5));
setInterval(shootSniper_3, SNIPERFIRERATE*(3/4));
setInterval(shootSniper_4, SNIPERFIRERATE*(1/2));

setInterval(shootGunner_0, GUNNERFIRERATE);
setInterval(shootGunner_1, GUNNERFIRERATE*(5/6));
setInterval(shootGunner_2, GUNNERFIRERATE*(4/5));
setInterval(shootGunner_3, GUNNERFIRERATE*(3/4));
setInterval(shootGunner_4, GUNNERFIRERATE*(1/2));

setInterval(shootCannon_0, CANNONFIRERATE);
setInterval(shootCannon_1, CANNONFIRERATE*(5/6));
setInterval(shootCannon_2, CANNONFIRERATE*(4/5));
setInterval(shootCannon_3, CANNONFIRERATE*(3/4));
setInterval(shootCannon_4, CANNONFIRERATE*(1/2));


setInterval(animsUI, 50);
setInterval(Timer, 15);
setInterval(adjustTowers, 10);
setInterval(blastFramesFunction, 50);


function getRandomIntInclusive(min, max) { // random function for ghost movement, returns integers
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1) + min); // The maximum is inclusive and the minimum is inclusive
}

function isInside(pos, arr) {
  for (let i =0; i < arr.length; i++) {
    if (arr[i] != null) {
      if (pos.x > arr[i].x && pos.x < arr[i].x + arr[i].w && pos.y < arr[i].y + arr[i].h && pos.y > arr[i].y) {
        return arr[i];
      }
    }
  }
  return null;
}

function isInsideCannon(pos, arr) {
  const ANIMOFFSET = 22;
  var found = false;
    for (let i =0; i < arr.length; i++) {
      if (arr[i] != null) {
        if (pos.x > arr[i].x && pos.x < arr[i].x + arr[i].w - ANIMOFFSET && pos.y < arr[i].y + arr[i].h - ANIMOFFSET && pos.y > arr[i].y) {
          arr[i].health -= 5;
          if (arr[i].health < 0) {
            pos.twr.totalDamageApplied+=arr[i].health;
          }
          pos.twr.totalDamageApplied+=pos.twr.damage;
          if (arr[i].health <= 0) {
            pos.twr.kills+=1;
          }
          found = true;
          break;
        }
      }
    }
  if (!found) {
    return null;
  }
  else {
    for (let i =0; i < arr.length; i++) {
      if (arr[i] != null) {
        if (pos.x+CANNONRANGE > arr[i].x && pos.x-CANNONRANGE < arr[i].x + arr[i].w - ANIMOFFSET && pos.y-CANNONRANGE < arr[i].y + arr[i].h - ANIMOFFSET && pos.y+CANNONRANGE > arr[i].y) {
          if (arr[i].health > 0) {
            arr[i].health -= 5;
            if (arr[i].health < 0) {
              pos.twr.totalDamageApplied+=arr[i].health;
            }
            pos.twr.totalDamageApplied+=pos.twr.damage;
          }
        }
      }
    }
    return true;
  }

}

function getMousePos(canvas, event) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  };
}

function randomN(lower, upper) { // random num gen from min to max (inclusive), returns floats
  return Math.random() * (upper - lower) + lower;
}

function snap() {
  var snapX = tmp.x+tmp.w/2;
  var snapY = tmp.y+tmp.h/2;
  var found = false;

  for (let i = 0; i < coords.length; i++) {
    if (coords[i].value == 0) {
      var coordX = coords[i].x+coords[i].w/2;
      var coordY = coords[i].y+coords[i].h/2;

      if ((coordX + 30 > snapX && coordX < snapX) || (coordX - 30 < snapX && coordX > snapX)) {
        if ((coordY + 30 > snapY && coordY < snapY) || (coordY - 30 < snapY && coordY > snapY)) {
          tmp.x = coords[i].x;
          tmp.y = coords[i].y;
          found = true;
        }
      }
    }
  }
  for (let i = 0; i < towers.length; i++) {
    if (towers[i].x == tmp.x && towers[i].y == tmp.y) {
      tmp = null;
    }
  }

  if (!found) {
    tmp = null;
  }
}



//EVENT LISTENERS
canvas.addEventListener("mousemove", function (event) {
  var mousePos = getMousePos(canvas, event);
  //updateBullet(bullets[bullets.length-1], mousePos);
  hoverButton = isInside(mousePos, buttons);
  hoverButton2 = isInside(mousePos, arrowButtons);
  if (tmp != null) {
    tmp.x = mousePos.x-tmp.w/2;
    tmp.y = mousePos.y-tmp.h/2;
  }
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].hover = false;
  }
  for (let i = 0; i < arrowButtons.length; i++) {
    arrowButtons[i].hover = false;
  }
  if (hoverButton == null && hoverButton2 == null) {
    return;    
  }
  if (hoverButton == null) {
    hoverButton2.hover = true;
  }
  else {
    hoverButton.hover = true;
  }



}, false);

canvas.addEventListener("mouseup", function (event) {
  var mousePos = getMousePos(canvas, event);
  if (tmp != null) {
    snap();
    if (tmp != null) {
      playClick();
      balance -= tmp.price;
        towers.push({
          type: tmp.type,
          x: tmp.x,
          y: tmp.y,
          w: tmp.w, 
          h: tmp.h,
          imgs: tmp.imgs,
          real: tmp.real,
          bullet: tmp.bullet,
          price: tmp.price,
          damage: tmp.damage,
          kills: tmp.kills,
          totalDamageApplied: tmp.totalDamageApplied,
          speed: tmp.speed,
          pierce: tmp.pierce,
          upgradeLevel0: tmp.upgradeLevel0,
          upgradeLevel1: tmp.upgradeLevel1,
          upgradeLevel2: tmp.upgradeLevel2,
        });
        selectedTower = towers.length-1;
    }

  }
  tmp = null;
  //updateBullet(bullets[bullets.length-1], mousePos);
}, false);

canvas.addEventListener("mousedown", function (event) {
  var mousePos = getMousePos(canvas, event);
  var selectedHero = isInside(mousePos, heroButtons);
  if (selectedHero == null) {
    tmp = null;
    return;
  }
  if (balance >= selectedHero.price) {
    tmp = {
      type: selectedHero.type,
      x: selectedHero.x,
      y: selectedHero.y,
      w: selectedHero.w, 
      h: selectedHero.h,
      imgs: selectedHero.imgs,
      real: selectedHero.real,
      bullet: selectedHero.bullet,
      price: selectedHero.price,
      damage: selectedHero.damage,
      kills: selectedHero.kills,
      totalDamageApplied: selectedHero.totalDamageApplied,
      speed: selectedHero.speed,
      pierce: selectedHero.pierce,
      upgradeLevel0: selectedHero.upgradeLevel0,
      upgradeLevel1: selectedHero.upgradeLevel1,
      upgradeLevel2: selectedHero.upgradeLevel2
    }
    tmp.x = mousePos.x-tmp.w/2;
    tmp.y = mousePos.y-tmp.h/2;
  }



}, false);


function addBullet(position, tower) {
  if (tower.type == GUNNER) {
    bullets.push({
      x: tower.x + tower.w/2-5, 
      y: tower.y + tower.h/2, 
      dx: 0, 
      dy: 0, 
      w: 5, 
      h: 5,
      twr: tower,
      active: true
    });
  }
  if (tower.type == CANNON) {
    bullets.push({
      x: tower.x + tower.w/2, 
      y: tower.y + tower.h/2, 
      dx: 0, 
      dy: 0, 
      w: 15, 
      h: 15,
      twr: tower,
      active: true
    });
  }
  if (tower.type == SNIPER) {
    bullets.push({
      x: tower.x + tower.w/2, 
      y: tower.y + tower.h/2, 
      dx: 0, 
      dy: 0, 
      w: 3, 
      h: 3,
      twr: tower,
      active: true
    });
  }


  updateBullet(bullets[bullets.length-1], position);
}

function updateBullet(bullet, position) {
  //const AVERAGESPEED = 3; // AVG == 2 --> 1.95 is what it comes out to, keep in mind
  if (bullet.x < XOFFSET || bullet.x > XOFFSET + GAMEWIDTH) {
    bullet.active = false;
  }
  if (bullet.y < YOFFSET || bullet.y > YOFFSET + GAMEHEIGHT) {
    bullet.active = false;
  }

  var AVERAGESPEED = bullet.twr.speed;


  
  var changeX = (position.x+position.w/2-bullet.x);
  var changeY = (position.y+position.w/2-bullet.y);

  changeX /=100;
  changeY /=100;


  while (changeX < AVERAGESPEED && changeY < AVERAGESPEED && changeX > 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY > -AVERAGESPEED && changeX < 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > -AVERAGESPEED && changeY < AVERAGESPEED && changeX < 0 && changeY > 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX < AVERAGESPEED && changeY > -AVERAGESPEED && changeX > 0 && changeY < 0) {
    changeX *=1.1;
    changeY *=1.1;
  }
  while (changeX > AVERAGESPEED || changeY > AVERAGESPEED || changeX < -AVERAGESPEED || changeY < -AVERAGESPEED) {
    changeX /= 1.05;
    changeY /= 1.05;
  }
  if (bullet.active) {
    bullet.dx = changeX;
    bullet.dy = changeY;
  }

}

function addWave() {
  bullets = [];
  waveCount+=1;
  const scalar = 12;
  if (waveCount < waves.length) {
    generateWave(waves[waveCount]);
  }
  else {
    const amt = scalar*(waveCount/5);
    generateWave({arr: [amt,   amt,   amt,   amt,     amt,   amt,    amt,    amt,    amt,   amt], waveNum: waveCount});
  }               // redEI,   blueEI,greenEI,grayEI,brownEI,pinkEI, limeEI, aquaEI, orangeEI, purpleEI
}

canvas.addEventListener('click', function(event) {
  var mousePos = getMousePos(canvas, event);
  //addBullet(mousePos, towers[towers.length-1]);
  var selectedButton = isInside(mousePos, buttons);
  var selectedArrow = isInside(mousePos, arrowButtons);
  var selectedTowerCheck = isInside(mousePos, towers);
  if (selectedTowerCheck != null) {
    for (let i = 0; i < towers.length; i++) {
          if (towers[i].x == selectedTowerCheck.x && towers[i].y == selectedTowerCheck.y) {
            selectedTower = i;
          }
        }


    return;
  }
  if (selectedButton != null) {
    if (selectedButton == nextWaveButton) {
      if (enemies.length == 0) {
        playClick();
        addWave();

      }
    }
  }
  else if (selectedArrow != null){
    if (towers[selectedTower] != null) {
      if (towers.length > 0) {
        if (selectedArrow.ind == 0) {
          if (towers[selectedTower].upgradeLevel0 < 4) {
            towers[selectedTower].upgradeLevel0++; // FIRE RATE

            playClick();
          }
        }
        else if (selectedArrow.ind == 1) {
          if (towers[selectedTower].upgradeLevel1 < 4) {
            towers[selectedTower].upgradeLevel1++;
            playClick();
          }
        }
        else if (selectedArrow.ind == 2) {
          if (towers[selectedTower].upgradeLevel2 < 4) {
            towers[selectedTower].upgradeLevel2++;
            playClick();
          }
        }


      }
    }

  }

}, false);

//HELPER FUNCTIONS
function checkHits() {
  for (let x = 0; x < bullets.length; x++) {
      if (bullets[x] == null) {
        continue;
      }
        if (enemies[bullets[x].twr.target] != null) {
          if (enemies[bullets[x].twr.target].active) {
            updateBullet(bullets[x], enemies[bullets[x].twr.target]);
          }
        }
        if (bullets[x].twr.type == CANNON) {
          var check = isInsideCannon(bullets[x], enemies);
          if (check != null) {
            playCannon();
            blastFrames.push({
              x: bullets[x].x+bullets[x].w/2,
              y: bullets[x].y+bullets[x].h/2,
              frame: 0
            });
            bullets[x] = null;
          }
          
        }
        else if (bullets[x].twr.type == SNIPER || bullets[x].twr.type == GUNNER) {
          var hitEnemy = isInside({x: bullets[x].x, y: bullets[x].y}, enemies);
          if (hitEnemy != null) {
            playHit();
            if (hitEnemy.health > 0) {
              hitEnemy.health-=bullets[x].twr.damage;
              if (hitEnemy.health < 0) {
                bullets[x].twr.totalDamageApplied+=hitEnemy.health;
              }
                bullets[x].twr.totalDamageApplied+=bullets[x].twr.damage;
              if (hitEnemy.health <= 0) {
                bullets[x].twr.kills++;
              }
              if (bullets[x].twr.kills >= bullets[x].twr.pierce) {
                bullets[x] = null;
                clean();
                return;
              }
            }

          }
        }


      }
}



function Timer() { // game timer
  seconds+=.15;
  checkHits(); 
}



function clean() {
  var filtered = bullets.filter(function (el) {
  return el != null;
  });
  bullets = filtered;
  var filtered = enemies.filter(function (el) {
  return el != null;
  });
  enemies = filtered;
  var filtered = blastFrames.filter(function (el) {
  return el != null;
  });
  blastFrames = filtered;
}


</script>


</html>